package naturaldate

import "time"

type parser Peg {
  t time.Time
  number int
  year int
  month time.Month
  dayOfMonth int
  weekday time.Weekday
  tzSign int
  tzHour int
  tzMinute int
  hasTime bool
  match string
}

Query
  <- <_ Expr _ Zone?> { p.match = text }

Expr
  <- NOW
  / RelativeMinutes
  / RelativeMinutes
  / RelativeHours
  / RelativeDays AtTime?
  / Time? RelativeDays
  / RelativeWeeks AtTime?
  / Time? RelativeWeeks
  / RelativeWeekdays AtTime?
  / Time? RelativeWeekdays
  / RelativeMonthDay AtTime?
  / RelativeMonth
  / RelativeYear
  / Date AtTime?
  / Time ON? Date
  / GoTimeFormat

GoTimeFormat
  <- Weekday Month _ DayOfMonthNum _ Time _ Year
    {
      t := p.t
      p.t = time.Date(p.year, p.month, p.dayOfMonth, t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), t.Location())
    }

AtTime <- COMMA? AT? Time

Date
  <- ( Month DayOfMonth? COMMA? Year / Year Month DayOfMonth? / DayOfMonth? Month COMMA? Year )
    {
       dom := p.dayOfMonth
       if dom == 0 {
          dom = 1
       }
       p.t = time.Date(p.year, p.month, dom, 0, 0, 0, 0, p.t.Location())
    }
  / ( < Year [-/] MonthNum [-/] DayOfMonthNum > / < DayOfMonthNum [-/] MonthNum [-/] Year > )
    {
       p.t = time.Date(p.year, p.month, p.dayOfMonth, 0, 0, 0, 0, p.t.Location())
    }

Year
  <- < [12][0-9][0-9][0-9] > _ { n, _ := strconv.Atoi(text); p.year = n }

MonthNum
  <- < [01]?[0-9] > _ { n, _ := strconv.Atoi(text); p.month = time.Month(n) }

DayOfMonthNum
  <- < [0-3][0-9] > _   { n, _ := strconv.Atoi(text); p.dayOfMonth = n }
  / < [0-9] > _         { n, _ := strconv.Atoi(text); p.dayOfMonth = n }

RelativeMinutes
  <- Number MINUTES AGO
    {
      p.t = p.t.Add(-time.Minute * time.Duration(p.number))
    }
  / (Number MINUTES FROM_NOW / In Number? MINUTES FROM_NOW?)
    {
      p.t = p.t.Add(time.Minute * time.Duration(p.number))
    }
  / Last Number? MINUTES
    {
      p.t = p.t.Add(-time.Minute * time.Duration(p.number))
    }
  / Next Number? MINUTES
    {
      p.t = p.t.Add(time.Minute * time.Duration(p.number))
    }
  / NEXT MINUTE
    {
      p.t = p.t.Add(time.Minute)
    }
  / LAST MINUTE
    {
      p.t = p.t.Add(-time.Minute)
    }

RelativeHours
  <- Number HOURS AGO
    { 
      p.t = p.t.Add(-time.Hour * time.Duration(p.number))
    }
  / (Number HOURS FROM_NOW / In Number? HOURS FROM_NOW?)
    { 
      p.t = p.t.Add(time.Hour * time.Duration(p.number))
    }
  / LAST HOUR
    {
      p.t = p.t.Add(-time.Hour)
    }
  / NEXT HOUR
    {
      p.t = p.t.Add(time.Hour)
    }

RelativeDays
  <- Number DAYS AGO
    {
      p.t = p.t.Add(-day * time.Duration(p.number))
      truncateDayIfNoTime(p)
    }
  / (Number DAYS FROM_NOW / In Number? DAYS FROM_NOW?)
    { 
      p.t = p.t.Add(day * time.Duration(p.number))
      truncateDayIfNoTime(p)
    }

RelativeWeeks
  <- Number WEEKS AGO
    {
      p.t = p.t.Add(-week * time.Duration(p.number))
      truncateDayIfNoTime(p)
    }
  / (Number WEEKS FROM_NOW / In Number? WEEKS FROM_NOW?)
    {
      p.t = p.t.Add(week * time.Duration(p.number))
      truncateDayIfNoTime(p)
    }
  / NEXT WEEK
    {
      p.t = p.t.Add(week)
      truncateDayIfNoTime(p)
    }
  / LAST WEEK
    {
      p.t = p.t.Add(-week)
      truncateDayIfNoTime(p)
    }

RelativeMonthDay
  <- NEXT Month DayOfMonth
    {
      p.t = nextMonthDayTime(p.t, p.month, p.dayOfMonth, 0, 0, 0)
    }
  / LAST Month DayOfMonth
    {
      p.t = prevMonthDayTime(p.t, p.month, p.dayOfMonth, 0, 0, 0)
    }

RelativeMonth
  <- Number MONTHS AGO
    {
      p.t = p.t.AddDate(0, -p.number, 0)
      truncateDayIfNoTime(p)
    }
  / (Number MONTHS FROM_NOW / In Number? MONTHS FROM_NOW?)
    {
      p.t = p.t.AddDate(0, p.number, 0)
      truncateDayIfNoTime(p)
    }
  / LAST Month
    {
      p.t = prevMonth(p.t, p.month)
      truncateDayIfNoTime(p)
    }
  / NEXT Month
    {
      p.t = nextMonth(p.t, p.month)
      truncateDayIfNoTime(p)
    }
  / LAST MONTH
    {
      p.t = p.t.AddDate(0, -1, 0)
      truncateDayIfNoTime(p)
    }
  / NEXT MONTH
    {
      p.t = p.t.AddDate(0, 1, 0)
      truncateDayIfNoTime(p)
    }

RelativeYear
  <- Number YEARS AGO
    {
      p.t = truncateYear(p.t.AddDate(-p.number, 0, 0))
    }
  / (Number YEARS FROM_NOW / In Number? YEARS FROM_NOW?)
    {
      p.t = truncateYear(p.t.AddDate(p.number, 0, 0))
    }
  / LAST YEAR
    {
      p.t = truncateYear(p.t.AddDate(-1, 0, 0))
    }
  / NEXT YEAR
    {
      p.t = truncateYear(p.t.AddDate(1, 0, 0))
    }


RelativeWeekdays
  <- TODAY
    {
      truncateDayIfNoTime(p)
    }
  / YESTERDAY 
    {
      p.t = p.t.Add(-day)
      truncateDayIfNoTime(p)
    }
  / TOMORROW
    {
      p.t = p.t.Add(+day)
      truncateDayIfNoTime(p)
    }
  / LAST Weekday
    {
      p.t = prevWeekday(p.t, p.weekday)
      truncateDayIfNoTime(p)
    }
  / NEXT Weekday
    {
      p.t = nextWeekday(p.t, p.weekday)
      truncateDayIfNoTime(p)
    }

DayOfMonth <- Number Ordinal? { p.dayOfMonth = p.number }

Time
  <- Clock12Hour Zone?
   / Clock24Hour Zone?

Zone
  <- UTC < ([-+][0-9])? > _
    {
       if text == "" {
          t := p.t
          p.t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), time.UTC)
       } else {
          offset, err := strconv.Atoi(text)
          if err != nil {
            panic(err)
          }
          name := fmt.Sprintf("UTC+%d", offset)
          if offset < 0 {
              name = fmt.Sprintf("UTC-%d", -offset)
          }
          tz := time.FixedZone(name, offset*60*60)
          t := p.t
          p.t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), tz)
       }
    }
  / 'z' _
    {
       t := p.t
       p.t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), time.UTC)
    }
  / < TzSign TzHour ':' TzMinute >
    {
       offset := p.tzSign * (p.tzHour*60*60 + p.tzMinute*60)
       name := text
       tz := time.FixedZone(name, offset)
       t := p.t
       p.t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), tz)
    }

TzSign <- < [-+] >
    {
       p.tzSign = 1
       if text == "-" {
         p.tzSign = -1
       }
    }
TzHour <- < [01][0-9] > { n, _ := strconv.Atoi(text); p.tzHour = n }
TzMinute <- < [0-5][0-9] > { n, _ := strconv.Atoi(text); p.tzMinute = n }

Clock12Hour
  <- Number
    {
      year, month, day := p.t.Date()
      p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())
      p.hasTime = true
    }
    (Minutes Seconds?)?
    AM _
  / Number
    {
      year, month, day := p.t.Date()
      p.t = time.Date(year, month, day, p.number + 12, 0, 0, 0, p.t.Location())
      p.hasTime = true
    }
    (Minutes Seconds?)?
    PM _

Clock24Hour
  <- Number
    {
      year, month, day := p.t.Date()
      p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())
      p.hasTime = true
    }
    (Minutes Seconds?)? _

Minutes
  <- ':' Number
    {
      t := p.t
      year, month, day := t.Date()
      hour, _, _ := t.Clock()
      p.t = time.Date(year, month, day, hour, p.number, 0, 0, t.Location())
    }

Seconds
  <- ':' Number
    {
      t := p.t
      year, month, day := t.Date()
      hour, min, _ := t.Clock()
      p.t = time.Date(year, month, day, hour, min, p.number, 0, t.Location())
    }

Number
  <- < [0-9]+ > _ { n, _ := strconv.Atoi(text); p.number = n }
  / 'a' 'n'? _    { p.number = 1 }
  / 'one' _       { p.number = 1 }
  / 'two' _       { p.number = 2 }
  / 'three' _     { p.number = 3 }
  / 'four' _      { p.number = 4 }
  / 'five' _      { p.number = 5 }
  / 'six' _       { p.number = 6 }
  / 'seven' _     { p.number = 7 }
  / 'eight' _     { p.number = 8 }
  / 'nine' _      { p.number = 9 }
  / 'ten' _       { p.number = 10 }

Weekday
  <- ('sunday' / 'sun') _   { p.weekday = time.Sunday }
  / ('monday' / 'mon') _    { p.weekday = time.Monday }
  / ('tuesday' / 'tue') _   { p.weekday = time.Tuesday }
  / ('wednesday' / 'wed') _ { p.weekday = time.Wednesday }
  / ('thursday' / 'thu') _  { p.weekday = time.Thursday }
  / ('friday' / 'fri') _    { p.weekday = time.Friday }
  / ('saturday' / 'sat') _  { p.weekday = time.Saturday }

Month
  <- ('january' / 'jan' DOT?) _  { p.month = time.January }
  / ('february' / 'feb' DOT?) _  { p.month = time.February }
  / ('march' / 'mar' DOT?) _     { p.month = time.March }
  / ('april' / 'apr') _     { p.month = time.April }
  / 'may' _       { p.month = time.May }
  / ('june' / 'jun' DOT?) _      { p.month = time.June }
  / ('july' / 'jul' DOT?) _      { p.month = time.July }
  / ('august' / 'aug' DOT?) _    { p.month = time.August }
  / ('september' / 'sep' DOT?) _ { p.month = time.September }
  / ('october' / 'oct' DOT?) _   { p.month = time.October }
  / ('november' / 'nov' DOT?) _  { p.month = time.November }
  / ('december' / 'dec' DOT?) _  { p.month = time.December }

In
  <- IN _        { p.number = 1}

Last
  <- LAST _      { p.number = 1 }

Next
  <- NEXT _      { p.number = 1 }

Ordinal
  <- ('st' / 'nd' / 'rd' / 'th') _

YEARS      <- 'year' 's'? _
YEAR       <- 'year' _
MONTHS     <- 'month' 's'? _
MONTH      <- 'month' _
WEEKS      <- 'week' 's'? _
WEEK       <- 'week' _
DAYS       <- 'day' 's'? _
HOURS      <- 'hour' 's'? _
HOUR       <- 'hour' _
MINUTES    <- 'minute' 's'? _
MINUTE     <- 'minute' _
YESTERDAY  <- 'yesterday' _
TOMORROW   <- 'tomorrow' _
TODAY      <- 'today' _
AGO        <- 'ago' _
FROM_NOW   <- ('from now' / 'from today') _
NOW        <- 'now' _
AM         <- 'am' _
PM         <- 'pm' _
NEXT       <- 'next' _
IN         <- ('in an' / 'in a' / 'in') _
LAST       <- ('last' / 'past' / 'previous') _
AT         <- 'at' _
ON         <- 'on' _
COMMA      <- ',' _
DOT        <- '.' _
UTC        <- 'utc' _
_
  <- Whitespace*

Whitespace
  <- ' ' / '\t' / EOL

EOL
  <- '\r\n' / '\n' / '\r'
